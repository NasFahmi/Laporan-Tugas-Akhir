%==================================================================
% Ini adalah bab 4
% Silahkan edit sesuai kebutuhan, baik menambah atau mengurangi \section, \subsection
%==================================================================

\chapter[HASIL DAN PEMBAHASAN]{\\ HASIL DAN PEMBAHASAN}

\section{Hasil Jawa Timur Datathon 2025}
\subsection{Capaian Jawa Timur Datathon 2025 Skema UMKM}
Jawa Timur Datathon 2025 merupakan kompetisi analisis data yang diselenggarakan oleh Dinas Komunikasi dan Informatika Provinsi Jawa Timur dengan tema \textit{“Shaping The Future with Open Data”}, yang bertujuan mendorong pemanfaatan Open Data Jawa Timur sebagai dasar dalam analisis data dan perumusan solusi berbasis data. Keikutsertaan dalam kompetisi ini menghasilkan capaian awal berupa perumusan ide, penyusunan proposal, serta pengembangan prototipe solusi yang berangkat dari permasalahan nyata dan data terbuka yang tersedia.

Capaian yang diperoleh pada Jawa Timur Datathon 2025 menjadi dasar pengembangan penelitian pada Tugas Akhir ini. Ide solusi, rancangan awal sistem, serta pendekatan analisis yang dikembangkan selama kompetisi tidak berhenti pada konteks lomba, melainkan dilanjutkan dan disempurnakan melalui proses penelitian yang terstruktur. Pada tahap lanjutan, sistem dikembangkan kembali dengan memperhatikan aspek arsitektur \textit{frontend}, penerapan arsitektur \textit{Client Data Layer} menggunakan TanStack Query, serta evaluasi mekanisme pengelolaan data \textit{frontend} sesuai dengan metodologi penelitian yang digunakan.

Dengan demikian, capaian Jawa Timur Datathon 2025 tidak hanya dipandang sebagai prestasi kompetitif, tetapi juga sebagai kontribusi awal yang mendukung pengembangan sistem dan penelitian secara akademik. Integrasi antara hasil lomba dan pengembangan lanjutan memungkinkan penelitian ini memiliki landasan implementatif yang kuat, sekaligus memenuhi kaidah ilmiah dalam proses analisis, pengujian, dan pelaporan Tugas Akhir.

\begin{longtable}{|
	p{0.25\linewidth}
	|>{\centering\arraybackslash}p{0.15\linewidth}
	|p{0.5\linewidth}|
}
\caption{Kriteria Penilaian Pengumpulan Proposal Ide Analisis Data dan Video}
\label{tab:kriteria_proposal} \\
\hline
\textbf{Kriteria} & \textbf{Bobot (\%)} & \textbf{Deskripsi Penilaian} \\
\hline
\endfirsthead

\hline
\textbf{Kriteria} & \textbf{Bobot (\%)} & \textbf{Deskripsi Penilaian} \\
\hline
\endhead

\hline
\endfoot

\hline
\endlastfoot

Relevansi Ide
& 30\%
& Tingkat kesesuaian ide yang diajukan dengan business case yang diberikan serta kemampuan ide tersebut untuk diselesaikan menggunakan data yang tersedia. \\ \hline

Inovasi dan Kreativitas
& 30\%
& Tingkat keunikan, kreativitas, dan kebaruan solusi yang diusulkan dibandingkan dengan pendekatan konvensional yang telah ada. \\ \hline

Feasibility (Kelayakan Solusi)
& 20\%
& Tingkat kelayakan solusi untuk diimplementasikan dengan mempertimbangkan keterbatasan waktu, teknologi, serta ketersediaan data. \\ \hline

Struktur dan Kualitas Proposal
& 10\%
& Kejelasan struktur proposal, ketepatan penggunaan bahasa, serta kelogisan alur argumentasi yang disampaikan. \\ \hline

Presentasi Proposal
& 10\%
& Kemampuan menyampaikan ide secara jelas, sistematis, dan persuasif melalui dokumen proposal dan video pendukung. \\ \hline

\end{longtable}


\begin{longtable}{|
	p{0.3\linewidth}
	|>{\centering\arraybackslash}p{0.15\linewidth}
	|p{0.45\linewidth}|
}
\caption{Kriteria Penilaian Babak Final Jawa Timur Datathon 2025}
\label{tab:kriteria_final} \\
\hline
\textbf{Kriteria} & \textbf{Bobot (\%)} & \textbf{Deskripsi Penilaian} \\
\hline
\endfirsthead

\hline
\textbf{Kriteria} & \textbf{Bobot (\%)} & \textbf{Deskripsi Penilaian} \\
\hline
\endhead

\hline
\endfoot

\hline
\endlastfoot

Kualitas Eksplorasi dan Pemahaman Data
& 20\%
& Kemampuan peserta dalam memahami karakteristik dataset, melakukan pembersihan data, serta menemukan insight awal yang relevan. \\ \hline

Kualitas Analisis dan Interpretasi
& 30\%
& Ketepatan dalam melakukan analisis data dan menarik kesimpulan yang logis serta berbasis bukti untuk mendukung rekomendasi. \\ \hline

Kualitas Visualisasi Data (Dashboard)
& 20\%
& Kualitas desain dashboard yang informatif, jelas, dan interaktif, serta kemudahan visualisasi dalam menyampaikan informasi kepada pengguna. \\ \hline

Kualitas Rekomendasi dan Insight
& 20\%
& Tingkat relevansi dan kebermanfaatan rekomendasi yang dihasilkan berdasarkan hasil analisis data. \\ \hline

Presentasi dan Storytelling Data
& 10\%
& Kemampuan tim dalam menyampaikan hasil analisis dan rekomendasi secara runtut, jelas, dan menarik melalui pendekatan storytelling data. \\ \hline

\end{longtable}

Setelah melalui seluruh tahapan seleksi, mulai dari pengajuan proposal hingga babak final, tim JEVON ORDRICK berhasil meraih peringkat ketiga pada Jawa Timur Datathon 2025.

 \begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{gambar/gambar-juara-3.jpeg}
    \caption{Pengumuman Juara 3 Jawa Timur Datathon 2025}
    \label{fig:juara-3}
  \end{figure}
  \FloatBarrier
Pada Gambar \ref{fig:juara-3} ditunjukkan bahwa tim JEVON ORDRICK berhasil meraih peringkat ketiga pada Jawa Timur Datathon 2025 melalui pengembangan dashboard analisis sentimen yang bertujuan membantu pelaku UMKM dalam menganalisis persepsi masyarakat terhadap produk atau layanan mereka berdasarkan data media sosial Instagram.
\section{Hasil}

\subsection{\textit{Analysis}}
Pada tahap \textit{analysis}, hasil yang diperoleh berupa identifikasi kebutuhan sistem \textit{frontend} dashboard analisis sentimen UMKM yang bersifat data-driven. Analisis menunjukkan bahwa data hasil analisis sentimen yang bersumber \textit{service} ABSA (\textit{Aspect Based Sentiment Analysis}) dan Rekomendasi Konten yang di salurkan ke backend digunakan oleh beberapa komponen antarmuka secara bersamaan, seperti dashboard utama, halaman sentiment, dan halaman rekomendasi. Kondisi ini menimbulkan kebutuhan akan mekanisme pengelolaan data \textit{frontend} yang mampu menjaga konsistensi data serta menghindari permintaan data berulang ke REST API.

Hasil analisis juga menunjukkan bahwa pengguna sistem hanya berperan sebagai konsumen informasi, sehingga kebutuhan utama sistem terletak pada stabilitas penyajian data, konsistensi antar-komponen, serta kemudahan navigasi tanpa kehilangan data. Temuan pada tahap ini menjadi dasar pemilihan arsitektur \textit{Client Data Layer} sebagai solusi pengelolaan data \textit{frontend}.

\subsection{\textit{Requirement Specification}}

Hasil dari tahap requirement specification adalah tersusunnya kebutuhan fungsional dan non-fungsional sistem \textit{frontend}. Kebutuhan fungsional mencakup kemampuan sistem untuk menampilkan ringkasan sentimen, visualisasi distribusi sentimen, data rekomendasi, serta data scraper yang bersumber dari REST API backend.

Kebutuhan non-fungsional yang dihasilkan pada tahap ini meliputi konsistensi data antar-komponen, pengendalian permintaan API, serta kemampuan sistem dalam memanfaatkan mekanisme caching. Kebutuhan tersebut menjadi acuan dalam perancangan arsitektur \textit{frontend} dan pemilihan TanStack Query sebagai pustaka pengelolaan \textit{Client Data Layer}.

\subsection{\textit{Design}}

Pada tahap design, dihasilkan rancangan arsitektur \textit{frontend} berbasis component-based architecture dengan pemisahan antara lapisan presentasi dan lapisan pengelolaan data. Hasil perancangan menunjukkan bahwa \textit{Client Data Layer} diposisikan sebagai lapisan perantara antara REST API dan komponen antarmuka pengguna.

Selain perancangan arsitektur, tahap ini juga menghasilkan rancangan penggunaan TanStack Query sebagai implementasi \textit{Client Data Layer}, serta Desain antarmuka untuk setiap halaman utama sistem. Rancangan tersebut menjadi acuan utama dalam proses implementasi \textit{frontend} pada tahap selanjutnya.
% \vspace{-1.3em}
\subsubsection{Arsitektur \textit{Frontend}}

Arsitektur \textit{frontend} pada sistem yang diimplementasikan juga ditunjukkan melalui cara penulisan dan pengelompokan file di dalam proyek \textit{frontend} yang mengikuti arsitektur yang diterapkan. Struktur \textit{frontend} disusun dengan pemisahan yang jelas antara komponen \textit{view}, logika pengelolaan data, serta definisi \textit{type} atau struktur data dari \textit{response} maupun \textit{payload}, dan aturan validasi atau \textit{schema} yang digunakan sistem. Pemisahan ini bertujuan untuk mendukung penerapan arsitektur \textit{frontend} yang terstruktur dan mudah dipelihara.

Komponen \textit{view} berperan sebagai lapisan antarmuka pengguna yang bertanggung jawab dalam menampilkan data dan menangani interaksi pengguna dengan sistem. Lapisan ini tidak menangani proses pengambilan data secara langsung, melainkan hanya menerima data yang telah dikelola oleh lapisan pengelolaan data. Dengan pendekatan ini, perubahan pada logika data tidak berdampak langsung terhadap tampilan antarmuka pengguna.

Lapisan logika pengelolaan data bertugas mengatur proses komunikasi dengan REST API, termasuk pengambilan data, pengelolaan status data, serta distribusi data ke komponen \textit{view}. Lapisan ini menjadi perantara antara sumber data eksternal dan antarmuka pengguna, sehingga seluruh pengelolaan data dapat dilakukan secara terpusat dan konsisten.

Definisi \textit{type} atau struktur data digunakan untuk merepresentasikan bentuk data yang dipertukarkan antara \textit{frontend} dan backend, baik dalam bentuk \textit{payload} permintaan maupun \textit{response} dari server. Aturan validasi atau \textit{schema} berfungsi untuk memastikan data yang diproses dan dikirimkan oleh sistem telah sesuai dengan format dan ketentuan yang ditetapkan. Pemisahan definisi struktur data dan aturan validasi ini membantu menjaga konsistensi data serta meminimalkan kesalahan pada proses pengolahan data.
% \vspace{-1.3em}
\subsubsection{\textit{Client Data Layer}}

Hasil implementasi menunjukkan bahwa pengelolaan data pada sistem \textit{frontend} berjalan secara konsisten pada seluruh halaman dashboard. Pada saat data pertama kali diakses oleh aplikasi, sistem mengambil data dari REST API dan menyimpannya sebagai bagian dari pengelolaan data internal. Data yang telah diperoleh tersebut selanjutnya digunakan kembali oleh fitur-fitur lain yang membutuhkan sumber data yang sama tanpa memicu permintaan ulang ke server. Alur pengelolaan data ini ditunjukkan pada Gambar~\ref{fig:tanstack-works}.

Penerapan pengelolaan data terpusat ini memengaruhi perilaku sistem pada saat aplikasi digunakan. Ketika pengguna melakukan navigasi antar-halaman dan kembali ke halaman sebelumnya, data tetap ditampilkan tanpa mengalami pemuatan ulang. Perilaku ini teramati secara konsisten pada halaman dashboard utama dan halaman dashboard sentimen yang menggunakan sumber data yang sama. Kondisi tersebut menunjukkan bahwa data yang telah diperoleh dapat dimanfaatkan kembali selama masih relevan dengan kebutuhan sistem.

Selain itu, implementasi \textit{Client Data Layer} juga berdampak pada efisiensi permintaan data. Ketika beberapa komponen \textit{frontend} membutuhkan data yang sama dalam waktu yang bersamaan, sistem tidak melakukan permintaan data secara terpisah untuk setiap komponen. Sebaliknya, satu hasil pengambilan data digunakan bersama oleh seluruh komponen terkait. Perilaku ini mengurangi permintaan data yang berulang dan mendukung efisiensi komunikasi antara \textit{frontend} dan backend.

Pengelolaan data melalui \textit{Client Data Layer} juga mendukung konsistensi penyajian data antar-komponen \textit{frontend}. Data yang digunakan oleh beberapa halaman atau komponen tetap berada pada kondisi yang selaras, sehingga tidak terjadi perbedaan informasi yang ditampilkan kepada pengguna. Dengan pendekatan ini, sistem \textit{frontend} mampu mempertahankan konsistensi data tanpa memerlukan pengelolaan state secara manual pada setiap komponen antarmuka.

Secara keseluruhan, penerapan \textit{Client Data Layer} menggunakan TanStack Query menghasilkan mekanisme pengelolaan data \textit{frontend} yang lebih terstruktur, konsisten, dan efisien pada tahap implementasi sistem. Lapisan ini mendukung kebutuhan aplikasi dashboard analisis sentimen yang bersifat data-driven, di mana data yang sama digunakan oleh berbagai komponen dan perlu disajikan secara konsisten selama siklus penggunaan aplikasi.
% \vspace{-1.3em}
\subsubsection{Desain Antarmuka}

Desain antarmuka yang telah disusun pada tahap perancangan sebelumnya digunakan sebagai acuan dalam proses implementasi sistem. Perancangan tersebut bertujuan untuk memastikan penyajian website dapat ditampilkan secara terstruktur, konsisten, dan mudah dipahami oleh pengguna melalui komponen visual seperti grafik, tabel, dan indikator ringkasan data.

Pada tahap desain, rancangan antarmuka disusun menggunakan alat bantu desain seperti Figma. \textit{Wireframe} digunakan sebagai panduan konseptual untuk menjaga konsistensi tampilan dan alur navigasi ketika sistem direalisasikan ke dalam website dengan menggunakan framework React.

Implementasi antarmuka dilakukan dengan menerjemahkan rancangan desain ke dalam komponen antarmuka yang bersifat modular dan reusable. Setiap komponen diintegrasikan dengan arsitektur \textit{frontend} berbasis data (data-driven), di mana tampilan antarmuka berfungsi sebagai representasi dari state data yang dikelola secara terpusat. Pendekatan ini memastikan bahwa perubahan data yang diperoleh dari backend dapat secara otomatis tercermin pada antarmuka pengguna tanpa memerlukan pengelolaan data secara manual di setiap komponen.

Selanjutnya, arsitektur \textit{frontend} yang telah dirancang di implementasi dengan mengintegrasikan \textit{Client Data Layer} menggunakan TanStack Query sebagai mekanisme utama dalam pengelolaan server state. Dengan penerapan arsitektur ini, proses pengambilan, penyimpanan sementara, dan sinkronisasi data dari REST API dapat dilakukan secara terstruktur, sehingga komponen antarmuka tidak berinteraksi langsung dengan API. Implementasi ini menjadi dasar bagi pengelolaan data yang konsisten dan efisien pada seluruh bagian dashboard.

Pendekatan ini juga mendukung pemisahan tanggung jawab (separation of concerns) antara lapisan presentasi dan pengelolaan data, sehingga kompleksitas logika aplikasi dapat diminimalkan. Selain itu, arsitektur berbasis \textit{Client Data Layer} mempermudah proses pemeliharaan dan pengembangan lanjutan sistem karena perubahan pada sumber data atau mekanisme pengambilan data tidak berdampak langsung pada komponen antarmuka

\subsection{\textit{Coding/Implementation}}
\subsubsection{Landing Page}

Landing Page diimplementasikan sebagai titik awal akses pengguna ke sistem sebelum proses autentikasi dilakukan. Pada halaman ini, \textit{frontend} hanya menyajikan informasi umum mengenai sistem dashboard analisis sentimen tanpa melakukan pengambilan maupun pengolahan data dari backend. Oleh karena itu, halaman ini tidak melibatkan mekanisme \textit{query} maupun \textit{mutation} dalam pengelolaan data menggunakan TanStack Query.

Implementasi Landing Page yang bersifat statis berfungsi untuk menegaskan pemisahan antara area sistem yang tidak bersifat \textit{data-driven} dan area sistem yang bergantung pada pengelolaan data server. Dengan pemisahan ini, aktivasi arsitektur \textit{Client Data Layer} hanya dilakukan setelah pengguna memasuki bagian sistem yang membutuhkan interaksi dengan backend, seperti proses autentikasi dan dashboard utama. Pendekatan ini menjaga konsistensi arsitektur \textit{frontend} agar tidak mencampurkan komponen non-data dengan mekanisme pengelolaan server state.

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{gambar/ui-landing-page.png}
    \caption{Implementasi Antarmuka Landing Page}
    \label{fig:implementasi-landing-page}
  \end{figure}
  \FloatBarrier
  
  Gambar~\ref{fig:implementasi-landing-page} menunjukkan hasil implementasi antarmuka landing page. Halaman ini berfungsi sebagai halaman awal sistem yang memberikan gambaran umum mengenai aplikasi dashboard analisis sentimen. Landing page menyediakan informasi singkat terkait fungsi sistem serta navigasi menuju halaman login dan registrasi bagi pengguna. dan juga pengguna bisa mengunjungi \textit{research version} untuk mengunjungi halaman pertama Sentinela ini ketika di perlombakan


\subsubsection{Authentication}
Fitur Authentication diimplementasikan untuk mengontrol akses pengguna terhadap sistem dashboard analisis sentimen. Proses autentikasi dilakukan melalui komunikasi \textit{frontend} dengan REST API backend untuk memvalidasi kredensial pengguna sebelum mengizinkan akses ke fitur yang bersifat data-driven. Pada tahap ini, sistem mulai melibatkan pertukaran data antara \textit{frontend} dan backend sebagai bagian dari alur penggunaan aplikasi.

Pada sisi \textit{frontend}, hasil autentikasi menentukan status akses pengguna terhadap \textit{Client Data Layer}. Pengambilan data menggunakan TanStack Query hanya dapat dilakukan setelah proses autentikasi berhasil, sehingga seluruh data dashboard berada dalam konteks pengguna yang valid. Implementasi ini memastikan bahwa pengelolaan data dan state aplikasi berjalan secara terkontrol serta mencegah akses data oleh pengguna yang tidak terautentikasi.

Hasil implementasi menunjukkan bahwa mekanisme autentikasi berfungsi sebagai gerbang awal sebelum \textit{Client Data Layer} aktif digunakan. Dengan pendekatan ini, sistem \textit{frontend} mampu membedakan area publik dan area terproteksi secara jelas, sekaligus menjaga konsistensi pengelolaan data pada seluruh fitur yang bergantung pada hasil autentikasi.


\FloatBarrier
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{gambar/ui-login-page.png}
    \caption{Implementasi Antarmuka Halaman Login}
    \label{fig:implementasi-login}
  \end{figure}
\FloatBarrier
  Gambar~\ref{fig:implementasi-login} menunjukkan antarmuka halaman login yang digunakan untuk proses autentikasi pengguna. Pada halaman ini, pengguna dapat memasukkan kredensial berupa alamat surel dan kata sandi untuk mengakses sistem. Implementasi halaman login memastikan bahwa hanya pengguna yang terdaftar yang dapat masuk ke dalam dashboard analisis sentimen.

\FloatBarrier
  
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{gambar/ui-register-page.png}
    \caption{Implementasi Antarmuka Halaman Register}
    \label{fig:implementasi-register}
  \end{figure}
\FloatBarrier
  Gambar~\ref{fig:implementasi-register} menampilkan hasil implementasi halaman registrasi pengguna. Halaman ini digunakan untuk proses pendaftaran pengguna baru dengan mengisi data yang diperlukan. Data yang dimasukkan pada halaman ini selanjutnya digunakan sebagai informasi akun untuk proses autentikasi pada sistem.


\FloatBarrier
\subsubsection{Dashboard}
\FloatBarrier
Dashboard diimplementasikan sebagai halaman ringkasan yang menyajikan sebagian informasi dari data sentimen dan rekomendasi konten. Data yang ditampilkan pada dashboard tidak diambil melalui \textit{query} tersendiri, melainkan memanfaatkan data yang telah tersedia pada \textit{Client Data Layer} dari halaman sentimen dan rekomendasi.

Pada implementasinya, dashboard berperan sebagai \textit{consumer data} yang memetakan sebagian data dari beberapa \textit{query} ke dalam komponen ringkasan. Pendekatan ini memungkinkan dashboard menampilkan informasi tanpa melakukan permintaan API tambahan, karena data telah dikelola secara terpusat oleh \textit{Client Data Layer}.

Hasil implementasi menunjukkan bahwa dashboard mampu menyajikan data yang konsisten dengan halaman sentimen dan rekomendasi. Perubahan data pada salah satu \textit{query} secara otomatis direfleksikan pada dashboard, yang menandakan bahwa pengelolaan \textit{server state} pada \textit{frontend} berjalan secara terintegrasi dan efisien.
\FloatBarrier
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{gambar/ui-dashboard-page.png}
    \caption{Implementasi Antarmuka Halaman Dashboard}
    \label{fig:implementasi-dashboard}
  \end{figure}
\FloatBarrier
  Gambar~\ref{fig:implementasi-dashboard} menunjukkan antarmuka halaman dashboard utama. Halaman ini berfungsi untuk menampilkan ringkasan hasil analisis sentimen dalam bentuk visualisasi dan informasi utama. Dashboard menjadi pusat akses pengguna terhadap fitur analisis sentimen dan rekomendasi konten yang tersedia pada sistem.

\FloatBarrier
\subsubsection{Scraper}
\FloatBarrier
Halaman Scraper diimplementasikan untuk menampilkan daftar data hasil proses pengambilan data media sosial yang dilakukan di sisi backend. Pada halaman ini, \textit{frontend} berperan sebagai konsumen data yang bersifat informatif dan tidak melakukan pemrosesan lanjutan terhadap data yang diterima.

Implementasi halaman Scraper hanya melibatkan satu \textit{query} aktif yang dikelola oleh \textit{Client Data Layer} untuk mengambil daftar data scraping. Pendekatan ini memastikan bahwa halaman Scraper tidak memicu pengambilan data yang tidak relevan serta tetap terpisah dari \textit{query} milik fitur lain.

Hasil implementasi menunjukkan bahwa pengelolaan data pada halaman Scraper berjalan secara terkontrol, di mana hanya \textit{query} yang sesuai dengan konteks halaman yang diaktifkan. Hal ini menegaskan bahwa \textit{Client Data Layer} mampu membatasi ruang lingkup pengambilan data sesuai kebutuhan fitur, sehingga arsitektur \textit{frontend} tetap tersegmentasi dengan baik.

  
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{gambar/ui-scraper-page.png}
    \caption{Implemenasi Antarmuka Halaman Scraper}
    \label{fig:implementasi-scraper}
  \end{figure}

  Gambar~\ref{fig:implementasi-scraper} menampilkan hasil implementasi halaman scraper. Halaman ini digunakan untuk melakukan proses pengambilan data dari sumber eksternal. Data yang berhasil dikumpulkan melalui halaman ini selanjutnya dapat digunakan sebagai bahan analisis pada sistem dashboard analisis sentimen.


\subsubsection{Sentiment}

Halaman Sentiment diimplementasikan untuk menyajikan hasil analisis sentimen secara rinci berdasarkan data yang diperoleh dari backend. Data sentimen dikelola melalui \textit{Client Data Layer} dan berfungsi sebagai satu sumber data yang dipercaya bagi fitur yang membutuhkan informasi sentimen, termasuk dashboard yang menampilkan ringkasan data tersebut.

Pada implementasinya, halaman Sentiment berperan sebagai consumer utama data sentimen, di mana satu query digunakan untuk mengambil dan mengelola data sentimen secara terpusat. Data yang diperoleh kemudian dipetakan ke berbagai komponen visualisasi tanpa melibatkan pengambilan data tambahan. Pendekatan ini memastikan bahwa seluruh tampilan yang memanfaatkan data sentimen mengacu pada sumber data yang sama.

Hasil implementasi menunjukkan bahwa data sentimen yang ditampilkan pada halaman Sentiment dan dashboard selalu konsisten. Setiap perubahan data pada \textit{Client Data Layer} secara otomatis direfleksikan pada kedua halaman tersebut, yang menandakan bahwa pengelolaan server state pada \textit{frontend} berjalan dengan baik dan mendukung penggunaan satu sumber data yang dipercaya.


  \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{gambar/ui-sentiment-page.png}
    \caption{Implementasi Antarmuka Halaman Sentiment}
    \label{fig:implementasi-sentiment}
  \end{figure}

  Gambar~\ref{fig:implementasi-sentiment} menampilkan antarmuka halaman analisis sentimen. Halaman ini digunakan untuk menyajikan hasil analisis sentimen secara lebih rinci berdasarkan data yang dianalisis. Informasi yang ditampilkan pada halaman ini membantu pengguna dalam memahami distribusi dan kecenderungan sentimen dari data yang diproses.


\subsubsection{Rekomendasi Konten}

Halaman rekomendasi konten diimplementasikan untuk menyajikan rekomendasi konten yang dihasilkan berdasarkan hasil analisis sentimen. Data rekomendasi diperoleh dari backend dan dikelola melalui \textit{Client Data Layer} sebelum ditampilkan pada antarmuka pengguna. Dengan demikian, fitur ini memanfaatkan hasil analisis sebagai dasar penyusunan rekomendasi yang relevan.

Pada implementasinya, halaman rekomendasi konten berperan sebagai consumer data rekomendasi, di mana satu query digunakan untuk mengelola pengambilan dan penyajian data secara terpusat. Data yang diperoleh tidak disimpan sebagai state lokal pada komponen, melainkan diakses langsung dari \textit{Client Data Layer}. Pendekatan ini memastikan bahwa data rekomendasi yang digunakan bersifat konsisten dan tidak terduplikasi.

Hasil implementasi menunjukkan bahwa data rekomendasi yang ditampilkan pada halaman rekomendasi konten dan dashboard selalu selaras. Setiap pembaruan data pada \textit{Client Data Layer} secara otomatis direfleksikan pada kedua halaman tersebut, yang menandakan bahwa pengelolaan data pada \textit{frontend} berjalan secara terintegrasi dengan mengacu pada satu sumber data yang dipercaya

 \begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{gambar/ui-recommendation-content-page.png}
    \caption{Implementasi Antarmuka Halaman Rekomendasi Konten}
    \label{fig:implementasi-recommendation-content}
  \end{figure}

  Gambar~\ref{fig:implementasi-recommendation-content} menunjukkan antarmuka halaman rekomendasi konten. Halaman ini menyajikan hasil rekomendasi konten yang dihasilkan berdasarkan analisis sentimen data. Informasi yang ditampilkan pada halaman ini bertujuan untuk mendukung pengambilan keputusan pengguna berdasarkan hasil analisis yang tersedia.


\subsubsection{Chatbot}
Fitur chatbot diimplementasikan sebagai komponen interaktif yang memungkinkan pengguna melakukan percakapan langsung dengan sistem untuk memperoleh informasi terkait analisis sentimen dan fungsi dashboard. Berbeda dengan halaman lain yang bersifat \textit{read-only}, fitur chatbot melibatkan interaksi dua arah antara pengguna dan backend.

Pada sisi \textit{frontend}, setiap pesan yang dikirimkan oleh pengguna diproses sebagai aksi yang memicu mekanisme \textit{mutation} menggunakan TanStack Query. Data pesan pengguna dikirimkan ke backend, kemudian sistem menunggu respons chatbot secara asinkron sebelum menampilkannya kembali pada antarmuka. Pendekatan ini memungkinkan pengelolaan alur komunikasi yang terstruktur tanpa perlu melakukan pengambilan data secara berkala menggunakan \textit{query}.

Riwayat percakapan dikelola sebagai state lokal pada komponen chatbot untuk menjaga kontinuitas interaksi selama sesi berlangsung. Sementara itu, TanStack Query berperan dalam mengelola status permintaan seperti \textit{loading}, \textit{success}, dan \textit{error}, sehingga antarmuka dapat memberikan umpan balik yang jelas kepada pengguna ketika proses pengiriman pesan sedang berlangsung atau mengalami kegagalan.

Implementasi fitur chatbot ini menunjukkan penerapan \textit{Client Data Layer} pada skenario komunikasi interaktif berbasis permintaan pengguna. Dengan memanfaatkan mekanisme \textit{mutation}, interaksi chatbot dapat diintegrasikan ke dalam arsitektur \textit{frontend} secara konsisten tanpa mengganggu pengelolaan server state pada fitur dashboard lainnya.


  \begin{figure}[H] 
    \centering 
    \includegraphics[width=0.4\textwidth]{gambar/ui-chatbot-page.png} 
    \caption{Desain Komponen Chatbot} 
    \label{fig:desain-chatbot} 
  \end{figure} 
  
  Gambar~\ref{fig:desain-chatbot} menampilkan hasil implementasi halaman chatbot. Halaman ini digunakan untuk user bisa melakukan chat dengan chatbot untuk mendapatkan informasi yang diperlukan.


\subsection{\textit{Testing}}

Pengujian sistem pada penelitian ini dilakukan untuk memverifikasi bahwa seluruh fitur yang telah dirancang dan diimplementasikan berfungsi sesuai dengan kebutuhan sistem yang telah ditetapkan pada Bab III. Pengujian dilakukan berdasarkan skenario pengujian yang telah disusun sebelumnya, dengan fokus pada pengujian fungsional dan perilaku sistem \textit{frontend} dalam mengelola data serta merespons interaksi pengguna.

Pada Bab ini, hasil pengujian disajikan dalam bentuk tabel hasil pengujian yang memuat hasil aktual dari setiap skenario pengujian. Informasi mengenai data uji dan hasil yang diharapkan tidak ditampilkan kembali pada bagian ini karena telah dijelaskan secara rinci pada Bab III. Dengan demikian, penyajian hasil pengujian pada Bab ini difokuskan pada pengamatan terhadap keluaran sistem dan status keberhasilan pengujian, guna menghindari pengulangan informasi dan menekankan pada hasil empiris dari proses pengujian yang telah dilakukan.
Berikut adalah hasil pengujian yang dilakukan pada sistem:

\begin{packed_enum}
    \item Landing Page
    
    \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Landing Page}
    \label{tab:hasil-pengujian-landing-page} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-LP-01 &
    Pengguna membuka aplikasi tanpa melakukan proses login &
    Halaman landing ditampilkan dengan informasi sistem serta navigasi menuju halaman login dan registrasi. &
    Halaman landing berhasil ditampilkan dengan informasi sistem serta navigasi menuju halaman login dan registrasi. &
    Berhasil \\
    \hline

    \end{longtable}

    \item Login

    \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Fitur Login}
    \label{tab:hasil-pengujian-login} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-LG-01 &
    Login dengan kredensial yang valid &
    Sistem memverifikasi kredensial pengguna dan mengarahkan pengguna ke halaman dashboard. &
    Sistem berhasil memverifikasi kredensial pengguna dan mengarahkan pengguna ke halaman dashboard. &
    Berhasil \\
    \hline

    TC-LG-02 &
    Login dengan kata sandi yang salah &
    Sistem menampilkan pesan kesalahan autentikasi dan tetap berada pada halaman login. &
    Sistem menampilkan pesan kesalahan autentikasi dan pengguna tetap berada pada halaman login. &
    Berhasil \\
    \hline

    TC-LG-03 &
    Login dengan username yang tidak terdaftar &
    Sistem menampilkan pesan bahwa akun tidak ditemukan dan tidak melanjutkan proses login. &
    Sistem menampilkan pesan bahwa akun tidak ditemukan dan tidak melanjutkan proses login. &
    Berhasil \\
    \hline

    TC-LG-04 &
    Login dengan field kosong &
    Sistem menampilkan pesan validasi bahwa seluruh field wajib diisi sebelum proses login dilakukan. &
    Sistem menampilkan pesan validasi bahwa seluruh field wajib diisi sebelum proses login dilakukan. &
    Berhasil \\
    \hline

    TC-LG-05 &
    Login berhasil setelah percobaan gagal &
    Sistem menerima kredensial yang valid dan mengarahkan pengguna ke halaman dashboard. &
    Sistem menerima kredensial yang valid dan mengarahkan pengguna ke halaman dashboard tanpa kendala. &
    Berhasil \\
    \hline

    \end{longtable}



    \item Register

    \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Fitur Register}
    \label{tab:hasil-pengujian-register} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-RG-01 &
    Registrasi dengan data yang valid &
    Sistem menyimpan data pengguna dan akun dapat digunakan untuk melakukan proses login. &
    Sistem berhasil menyimpan data pengguna dan akun dapat digunakan untuk melakukan proses login. &
    Berhasil \\
    \hline

    TC-RG-02 &
    Registrasi dengan data tidak lengkap &
    Sistem menampilkan pesan validasi bahwa seluruh data registrasi wajib diisi dan proses pendaftaran tidak dilanjutkan. &
    Sistem menampilkan pesan validasi bahwa seluruh data registrasi wajib diisi dan proses pendaftaran tidak dilanjutkan. &
    Berhasil \\
    \hline

    TC-RG-03 &
    Registrasi dengan username yang sudah terdaftar &
    Sistem menampilkan pesan bahwa akun dengan username tersebut sudah terdaftar dan proses pendaftaran dibatalkan. &
    Sistem menampilkan pesan bahwa akun dengan username tersebut sudah terdaftar dan proses pendaftaran dibatalkan. &
    Berhasil \\
    \hline

    TC-RG-04 &
    Registrasi ulang setelah kesalahan sebelumnya &
    Sistem menerima data registrasi yang valid dan proses pendaftaran berhasil diselesaikan. &
    Sistem menerima data registrasi yang valid dan proses pendaftaran berhasil diselesaikan. &
    Berhasil \\
    \hline

    \end{longtable}

    \item Dashboard

    \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Fitur Dashboard}
    \label{tab:hasil-pengujian-dashboard} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-DB-01 &
    Membuka halaman dashboard setelah login &
    Sistem menampilkan ringkasan data dan visualisasi utama dashboard sesuai data yang tersedia. &
    Sistem berhasil menampilkan ringkasan data dan visualisasi utama dashboard sesuai data yang tersedia. &
    Berhasil \\
    \hline

    TC-DB-02 &
    Membuka dashboard saat data belum tersedia &
    Sistem menampilkan indikator pemuatan dan informasi status tanpa menimbulkan kesalahan tampilan. &
    Sistem menampilkan indikator pemuatan dan informasi status tanpa menimbulkan kesalahan tampilan. &
    Gagal \\
    \hline

    TC-DB-03 &
    Navigasi ke menu lain dan kembali ke dashboard &
    Data dashboard tetap ditampilkan secara konsisten tanpa kehilangan atau perubahan data. &
    Data dashboard tetap ditampilkan secara konsisten tanpa kehilangan atau perubahan data. &
    Berhasil \\
    \hline

    TC-DB-04 &
    Pembaruan data dashboard dari server &
    Sistem memperbarui tampilan dashboard sesuai dengan data terbaru yang diterima. &
    Sistem memperbarui tampilan dashboard sesuai dengan data terbaru yang diterima. &
    Berhasil \\
    \hline

    TC-DB-05 &
    Konsistensi data antar komponen dashboard &
    Seluruh komponen dashboard menampilkan data yang konsisten karena mengacu pada satu sumber data. &
    Seluruh komponen dashboard menampilkan data yang konsisten karena mengacu pada satu sumber data. &
    Berhasil \\
    \hline

    \end{longtable}


    % \vspace{8cm}
    \item Sentiment

    \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Halaman Dashboard Sentiment}
    \label{tab:hasil-pengujian-sentiment} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-ST-01 &
    Membuka halaman dashboard sentiment &
    Sistem menampilkan visualisasi dan ringkasan hasil analisis sentimen sesuai dengan data yang tersedia. &
    Sistem berhasil menampilkan visualisasi dan ringkasan hasil analisis sentimen sesuai dengan data yang tersedia. &
    Berhasil \\
    \hline

    TC-ST-02 &
    Membuka dashboard sentiment saat data belum tersedia &
    Sistem menampilkan indikator pemuatan atau pesan informasi tanpa menimbulkan kesalahan tampilan. &
    Sistem menampilkan indikator pemuatan atau pesan informasi tanpa menimbulkan kesalahan tampilan. &
    Berhasil \\
    \hline

    TC-ST-03 &
    Pembaruan data sentimen dari server &
    Sistem memperbarui visualisasi dan ringkasan sentimen sesuai dengan data sentimen terbaru. &
    Sistem memperbarui visualisasi dan ringkasan sentimen sesuai dengan data sentimen terbaru. &
    Berhasil \\
    \hline

    TC-ST-04 &
    Navigasi keluar dan kembali ke dashboard sentiment &
    Data sentimen tetap ditampilkan secara konsisten tanpa kehilangan atau perubahan data. &
    Data sentimen tetap ditampilkan secara konsisten tanpa kehilangan atau perubahan data. &
    Berhasil \\
    \hline

    TC-ST-05 &
    Konsistensi data sentimen antar komponen &
    Seluruh komponen visualisasi menampilkan data sentimen yang konsisten karena mengacu pada satu sumber data. &
    Seluruh komponen visualisasi menampilkan data sentimen yang konsisten karena mengacu pada satu sumber data. &
    Berhasil \\
    \hline

    \end{longtable}


    \vspace*{6.5cm}
    \item Rekomendasi Konten

    \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Halaman Dashboard Rekomendasi Konten}
    \label{tab:hasil-pengujian-recommendation} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-RC-01 &
    Membuka halaman dashboard rekomendasi konten &
    Sistem menampilkan daftar rekomendasi konten berdasarkan data analisis sentimen yang tersedia. &
    Sistem berhasil menampilkan daftar rekomendasi konten berdasarkan data analisis sentimen yang tersedia. &
    Berhasil \\
    \hline

    TC-RC-02 &
    Membuka halaman rekomendasi saat data belum tersedia &
    Sistem menampilkan indikator pemuatan atau pesan informasi tanpa menimbulkan kesalahan tampilan. &
    Sistem menampilkan indikator pemuatan atau pesan informasi tanpa menimbulkan kesalahan tampilan. &
    Berhasil \\
    \hline

    TC-RC-03 &
    Pembaruan data rekomendasi dari server &
    Sistem memperbarui daftar rekomendasi sesuai dengan data rekomendasi terbaru yang diterima. &
    Sistem memperbarui daftar rekomendasi sesuai dengan data rekomendasi terbaru yang diterima. &
    Berhasil \\
    \hline

    TC-RC-04 &
    Navigasi keluar dan kembali ke dashboard rekomendasi &
    Data rekomendasi tetap ditampilkan secara konsisten tanpa kehilangan atau perubahan data. &
    Data rekomendasi tetap ditampilkan secara konsisten tanpa kehilangan atau perubahan data. &
    Berhasil \\
    \hline

    TC-RC-05 &
    Konsistensi rekomendasi dengan data sentimen &
    Rekomendasi konten menyesuaikan perubahan data sentimen yang digunakan sebagai dasar penyusunan rekomendasi. &
    Rekomendasi konten menyesuaikan perubahan data sentimen yang digunakan sebagai dasar penyusunan rekomendasi. &
    Berhasil \\
    \hline

    \end{longtable}



    \item Scraper

    \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Halaman Data Scraper}
    \label{tab:hasil-pengujian-scraper} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-SC-01 &
    Membuka halaman data scraper &
    Sistem menampilkan daftar data hasil scraping yang diperoleh dari server. &
    Sistem berhasil menampilkan daftar data hasil scraping yang diperoleh dari server. &
    Berhasil \\
    \hline

    TC-SC-02 &
    Membuka halaman scraper saat data belum tersedia &
    Sistem menampilkan indikator pemuatan atau pesan informasi tanpa menimbulkan kesalahan tampilan. &
    Sistem menampilkan indikator pemuatan atau pesan informasi tanpa menimbulkan kesalahan tampilan. &
    Berhasil \\
    \hline

    TC-SC-03 &
    Memilih data untuk dianalisis &
    Sistem menandai dataset yang dipilih dan data tersebut siap digunakan pada proses analisis. &
    Sistem berhasil menandai dataset yang dipilih dan data tersebut siap digunakan pada proses analisis. &
    Berhasil \\
    \hline

    TC-SC-04 &
    Navigasi keluar dan kembali ke halaman data scraper &
    Data hasil scraping tetap ditampilkan secara konsisten tanpa kehilangan atau perubahan data. &
    Data hasil scraping tetap ditampilkan secara konsisten tanpa kehilangan atau perubahan data. &
    Berhasil \\
    \hline

    \end{longtable}
    
    \clearpage
    \item Chatbot

   \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Fitur Chatbot}
    \label{tab:hasil-pengujian-chatbot} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-CB-01 &
    Membuka antarmuka chatbot pada dashboard &
    Sistem menampilkan antarmuka chatbot dan siap menerima input pengguna. &
    Sistem menampilkan antarmuka chatbot pada dashboard dan siap menerima input pengguna. &
    Berhasil \\
    \hline

    TC-CB-02 &
    Mengirimkan pertanyaan melalui chatbot &
    Sistem menampilkan respons chatbot sesuai dengan pertanyaan yang diberikan. &
    Sistem menampilkan respons chatbot sesuai dengan pertanyaan teks yang dikirimkan. &
    Berhasil \\
    \hline

    TC-CB-03 &
    Mengirimkan input kosong pada chatbot &
    Sistem menampilkan pesan validasi atau informasi bahwa input tidak valid. &
    Sistem menampilkan pesan validasi ketika pengguna mengirimkan input kosong. &
    Berhasil \\
    \hline

    TC-CB-04 &
    Mengirimkan pertanyaan di luar konteks sistem &
    Sistem menampilkan respons atau pesan informasi yang sesuai. &
    Sistem menampilkan pesan informasi yang sesuai untuk pertanyaan di luar konteks sistem. &
    Berhasil \\
    \hline

    TC-CB-05 &
    Interaksi berulang dengan chatbot &
    Sistem mampu menampilkan respons secara konsisten pada setiap interaksi. &
    Sistem menampilkan respons chatbot secara konsisten pada setiap interaksi berulang. &
    Berhasil \\
    \hline

    \end{longtable}

     \clearpage
    \item Logout

    \setlength{\arrayrulewidth}{0.8pt}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\tabcolsep}{4pt}
    \begin{longtable}{|
    >{\centering\arraybackslash}p{1.7cm} |
    p{2.5cm} |
    p{4cm} |
    p{4.5cm} |
    >{\centering\arraybackslash}p{1.5cm} |
    }
    \caption{Hasil Pengujian Fitur Logout}
    \label{tab:hasil-pengujian-logout} \\

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endfirsthead

    \hline
    \textbf{ID} &
    \textbf{Skenario Pengujian} &
    \textbf{Expected Result} &
    \textbf{Hasil Aktual} &
    \textbf{Status} \\
    \hline
    \endhead

    \endfoot

    \hline
    \endlastfoot

    TC-LO-01 &
    Pengguna melakukan logout dari sistem &
    Sistem mengakhiri sesi pengguna dan mengarahkan pengguna ke halaman login. &
    Sistem berhasil mengakhiri sesi pengguna dan mengarahkan pengguna ke halaman login. &
    Berhasil \\
    \hline

    TC-LO-02 &
    Pengguna mencoba mengakses halaman dashboard setelah logout &
    Sistem menolak akses dashboard dan mengarahkan pengguna kembali ke halaman login. &
    Sistem menolak akses dashboard dan mengarahkan pengguna kembali ke halaman login. &
    Berhasil \\
    \hline

    TC-LO-03 &
    Pengguna menutup sesi dan membuka ulang aplikasi &
    Sistem meminta pengguna untuk melakukan login kembali sebelum mengakses fitur sistem. &
    Sistem meminta pengguna untuk melakukan login kembali sebelum mengakses fitur sistem. &
    Berhasil \\
    \hline

    \end{longtable}

      
  \end{packed_enum}

  Secara kuantitatif, hasil pengujian fungsional menunjukkan tingkat keberhasilan sebesar 97,3\%, yang diperoleh dari 36 skenario pengujian berhasil dari total 37 skenario yang dirancang dan dilaksanakan. Sementara itu, tingkat kegagalan pengujian tercatat sebesar 2,7\%, yang berasal dari satu skenario pengujian yang tidak sepenuhnya memenuhi \textit{expected result}. Persentase keberhasilan ini mengindikasikan bahwa sistem telah berfungsi memenuhi sebagian besar kebutuhan fungsional yang ditetapkan, dengan kegagalan yang terjadi bersifat minor dan tidak memengaruhi fungsi utama sistem secara keseluruhan.

  Satu skenario pengujian yang dinyatakan gagal terdapat pada TC-DB-02 (Membuka dashboard saat data belum tersedia). Pada skenario ini, expected result menetapkan bahwa sistem secara langsung menampilkan indikator pemuatan (loading indicator) setelah pengguna berhasil login dan mengakses halaman dashboard. Namun, hasil pengujian menunjukkan bahwa sistem terlebih dahulu menampilkan \textit{state} data kosong dalam durasi singkat sebelum indikator pemuatan ditampilkan. Kondisi ini disebabkan oleh adanya jeda transisi \textit{state} antara proses inisialisasi halaman dashboard dan proses pengambilan data dari server, sehingga indikator pemuatan tidak langsung muncul pada saat halaman pertama kali dirender. 
  
  Meskipun tidak menimbulkan kesalahan fungsional maupun kegagalan sistem secara keseluruhan, perilaku tersebut dinilai tidak sepenuhnya sesuai dengan \textit{expected result}, sehingga skenario pengujian ini dikategorikan sebagai gagal.


\section{Pembahasan}

\subsection{Peran Arsitektur \textit{Client Data Layer} dalam Pengelolaan Data \textit{Frontend}}

  Penerapan arsitektur \textit{Client Data Layer} pada sistem yang dikembangkan berperan sebagai lapisan perantara antara REST API dan komponen antarmuka pengguna. Data hasil analisis sentimen yang diperoleh dari backend tidak diakses secara langsung oleh komponen antarmuka, melainkan dikelola terlebih dahulu melalui lapisan \textit{Client Data Layer}. Pendekatan ini memungkinkan pemisahan tanggung jawab yang jelas antara logika pengelolaan data dan logika presentasi antarmuka pengguna.

  Berdasarkan hasil pengujian dan observasi terhadap perilaku sistem, penerapan \textit{Client Data Layer} menunjukkan perubahan yang signifikan dalam pengelolaan data \textit{frontend}. Data yang sama dapat digunakan secara bersama oleh beberapa komponen dashboard tanpa memicu permintaan berulang ke server. Selain itu, konsistensi data antar-komponen tetap terjaga ketika pengguna berpindah halaman atau kembali ke halaman sebelumnya, karena data dikelola dalam satu sumber kebenaran yang terpusat di sisi klien. Temuan ini menunjukkan bahwa \textit{Client Data Layer} berperan dalam mengendalikan alur pengambilan, penyimpanan, dan distribusi data secara lebih terkontrol.

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{gambar/folder-structure-features.png}
    \caption{Struktur Folder Per Fitur}
    \label{fig:struktur-folder-fitur}
  \end{figure}

  Penerapan arsitektur tersebut juga tercermin pada pengorganisasian struktur proyek. Seperti ditunjukkan pada Gambar \ref{fig:struktur-folder-fitur}, setiap fitur utama ditempatkan dalam direktori terpisah yang memuat lapisan-lapisan dengan tanggung jawab yang berbeda. Struktur ini digunakan untuk memastikan bahwa pengelolaan data, akses ke sumber data, dan penyajian antarmuka tidak saling bercampur secara langsung.

  Dalam konteks dashboard analitik, peran \textit{Client Data Layer} menjadi semakin relevan karena sistem bergantung pada data dinamis yang digunakan secara simultan oleh berbagai komponen visualisasi. Dengan pengelolaan data yang terpusat, sistem \textit{frontend} mampu menyajikan informasi secara lebih stabil dan konsisten tanpa membebani backend dengan permintaan API yang tidak diperlukan. Hal ini memperkuat bahwa penerapan arsitektur \textit{Client Data Layer} mendukung pengelolaan data \textit{frontend} yang lebih terstruktur, khususnya dalam menjaga konsistensi data dan mengendalikan interaksi antara \textit{frontend} dan backend.

\subsection{Analisis Implementasi TanStack Query terhadap Server State}

Implementasi arsitektur \textit{Client Data Layer} pada sistem \textit{frontend} direalisasikan dengan memanfaatkan TanStack Query sebagai mekanisme utama dalam pengelolaan server state. Penggunaan TanStack Query memungkinkan data yang bersumber dari REST API dikelola secara terpusat di sisi klien, sehingga komponen antarmuka tidak berinteraksi langsung dengan proses pengambilan data. Dengan pendekatan ini, TanStack Query berperan sebagai fondasi teknis yang mendukung penerapan \textit{Client Data Layer} dalam sistem yang dikembangkan.

\begin{figure}[H]
  \centering
  \lstinputlisting{kode/query-client.ts}
  \caption{Konfigurasi Query Client}
  \label{fig:query-client}
\end{figure}

% query client
Konfigurasi global TanStack Query pada sistem ini direalisasikan melalui inisialisasi \mbox{\textit{query client}} yang bisa dilihat pada Gambar \ref{fig:query-client}, query client berfungsi sebagai pusat mekanisme pengelolaan server state pada sisi \textit{frontend}. \mbox{\textit{query client}} digunakan untuk menetapkan nilai \mbox{\textit{default options}}, seperti mekanisme \mbox{\textit{caching}}, \mbox{\textit{retry}}, serta \mbox{\textit{refetching}}, sehingga seluruh proses pengambilan dan perubahan data memiliki karakteristik yang konsisten.

\begin{figure}[H]
  \centering
  \lstinputlisting{kode/query-keys-sebagian.ts}
  \caption{Konfigurasi Query Keys}
  \label{fig:query-keys}
\end{figure}

% query keys
Dalam konteks pengambilan data, TanStack Query digunakan untuk menangani permintaan data hasil analisis sentimen dari backend melalui mekanisme \textit{query}. Setiap data yang dikelola oleh TanStack Query diidentifikasi menggunakan \textit{query key} yang bersifat unik. Konfigurasi dasar dapat dilihat pada Gambar \ref{fig:query-keys}. \textit{Query key} ini berfungsi sebagai identitas data dalam mekanisme \textit{cache}, sehingga pemisahan jenis data dan pengendalian \textit{invalidasi} dapat dilakukan secara lebih sistematis. Struktur \textit{query key} yang digunakan dalam penelitian ini bisa di lihat secara lengkap pada \ref{app:source-code} poin 2, yang memperlihatkan bagaimana setiap \textit{keys} dalam sistem \textit{frontend} dikumpulkan dalam satu tempat agar mudah dalam skalabilitasnya.

Berdasarkan hasil pengujian sistem, pendekatan ini memungkinkan data yang sama digunakan secara bersama oleh beberapa komponen dashboard tanpa memicu permintaan ulang ke server. Dengan demikian, konsistensi data antar-komponen dapat terjaga, khususnya ketika pengguna berpindah halaman atau melakukan navigasi ulang pada dashboard.

\begin{figure}[H]
  \centering
  \lstinputlisting{kode/scraper.repository-sebagian.tsx}
  \caption{Konfigurasi Repository}
  \label{fig:repository-sebagian}
\end{figure}


\begin{figure}[H]
  \centering
  \lstinputlisting{kode/scraper-sebagian.ts}
  \caption{Konfigurasi Scraper}
  \label{fig:scraper-sebagian}
\end{figure}


% repository layer & interface
Alur pengelolaan query diawali pada \textit{repository layer}, yang bertugas menangani interaksi langsung dengan REST API. \textit{Repository layer} berfungsi untuk memisahkan logika komunikasi data dari logika pengelolaan server state, sehingga komponen antarmuka tidak bergantung langsung pada detail pemanggilan API. Kode dari \ref{fig:repository-sebagian} menunjukkan bagaimana implementasi \textit{repository layer} yang digunakan dalam sistem ini, lebih lengkapnya dapat dilihat pada \ref{app:source-code} poin 3, Data yang diperoleh dari REST API selanjutnya dimodelkan menggunakan interface untuk memastikan kesesuaian struktur data sebelum dikelola oleh TanStack Query. Implementasi interface yang digunakan sebagai kontrak data ditunjukkan pada Gambar \ref{fig:scraper-sebagian} dan dapat dilihat secara detail pada \ref{app:source-code} poin 4.


\begin{figure}[H]
  \centering
  \lstinputlisting{kode/useLoginMutation-sebagian.ts}
  \caption{Konfigurasi Repository}
  \label{fig:repository-sebagian}
\end{figure}


\begin{figure}[H]
  \centering
  \lstinputlisting{kode/useScraperQuery-sebagian.ts}
  \caption{Konfigurasi Scraper}
  \label{fig:scraper-sebagian}
\end{figure}


% mekanisme query dan mutation
Selain mekanisme pengambilan data, pengelolaan perubahan data juga menjadi bagian penting dalam penerapan TanStack Query pada sistem \textit{frontend} yang dikembangkan. TanStack Query menyediakan dua mekanisme utama, yaitu \textit{query} untuk menangani pengambilan data dan \textit{mutation} untuk menangani perubahan data yang berdampak pada kondisi sistem. Kode \textit{Query} dan \textit{mutation} bisa dilihat pada Gambar \ref{fig:repository-sebagian} dan \ref{fig:scraper-sebagian}. Kedua mekanisme ini bekerja secara terintegrasi dalam mengendalikan alur data antara \textit{frontend} dan \textit{backend}, baik pada fase pemuatan data awal maupun setelah terjadi perubahan data.

Implementasi mekanisme \textit{query} pada sistem ini direalisasikan dalam bentuk \textit{custom hook} yang mengatur proses pengambilan data dari \textit{repository layer} serta pengelolaan \textit{server state} menggunakan TanStack Query. \textit{Custom hook query} tersebut bertugas mendefinisikan \textit{query key}, mengatur fungsi pengambilan data, serta mengelola status proses asinkron seperti \textit{loading}, \textit{success}, dan \textit{error} sebelum data digunakan oleh komponen antarmuka pengguna. Implementasi \textit{custom hook query} bisa di lihat secara lengkap pada \ref{app:source-code} poin 5.

Mekanisme \textit{mutation} pada TanStack Query diimplementasikan melalui \textit{custom hook mutation} yang bertanggung jawab dalam menangani proses perubahan data dari sisi \textit{frontend} ke backend. \textit{Custom hook mutation} ini mengelola status perubahan data serta berinteraksi dengan \textit{query client} untuk mengendalikan pembaruan dan sinkronisasi data setelah proses \textit{mutation} selesai. Implementasi \textit{custom hook mutation} bisa di lihat secara lengkap pada \ref{app:source-code} poin 6.

Dengan adanya pemisahan implementasi antara mekanisme \textit{query} dan \textit{mutation} melalui \textit{custom hook} yang terstruktur, alur pengelolaan \textit{server state} pada sisi \textit{frontend} dapat diamati secara lebih sistematis. Mekanisme \textit{query} berperan dalam menyediakan data yang dapat digunakan kembali oleh berbagai komponen antarmuka, sedangkan mekanisme \textit{mutation} berfungsi untuk mengelola perubahan data serta sinkronisasi data setelah perubahan terjadi. Untuk memperjelas hubungan antara \textit{repository layer}, \textit{query client}, \textit{custom hook}, mekanisme \textit{query} dan \textit{mutation}, serta komponen antarmuka pengguna dalam kedua mekanisme tersebut disajikan pada Gambar \ref{fig:alur-pengelolaan-query-tanstack-query} dan Gambar \ref{fig:skema-mutation-tanstack-query}.


\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{gambar/implementasi-arsitektur-tanstackquery.png}
\caption{Diagram Alur Pengelolaan Query menggunakan TanStack Query}
\label{fig:alur-pengelolaan-query-tanstack-query}
\end{figure}

Berdasarkan Gambar \ref{fig:alur-pengelolaan-query-tanstack-query}, terlihat alur pengelolaan \textit{query} diawali pada \textit{repository layer}, di mana respons data dari REST API diterima dan diproses. Data tersebut kemudian diberikan tipe data melalui \textit{interface} sebelum dikelola pada lapisan \textit{hooks} yang mengimplementasikan TanStack Query. Pada lapisan ini, TanStack Query mengendalikan mekanisme \textit{caching}, \textit{invalidasi}, dan \textit{refetch} data. Selanjutnya, data yang telah dikelola dipetakan ke dalam bentuk \textit{entity} untuk memastikan konsistensi struktur data sebelum dikirimkan ke lapisan presentasi atau UI.

Pendekatan ini memungkinkan komponen antarmuka pengguna mengakses data melalui satu sumber kebenaran yang terpusat, sehingga risiko inkonsistensi data antar-komponen dapat diminimalkan. Selain itu, dengan pemanfaatan mekanisme \textit{cache} pada lapisan \textit{query}, sistem mampu menghindari pemanggilan ulang REST API yang bersifat redundan ketika data yang sama digunakan kembali pada tampilan yang berbeda.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{gambar/skema-mutation-tanstack-query.png}
\caption{Diagram Alur Pengelolaan Mutation menggunakan TanStack Query}
\label{fig:skema-mutation-tanstack-query}
\end{figure}

Berdasarkan Gambar \ref{fig:skema-mutation-tanstack-query}, terlihat alur implementasi mekanisme \textit{mutation} dalam arsitektur \textit{Client Data Layer} menggunakan TanStack Query. Proses \textit{mutation} diawali dari lapisan antarmuka pengguna, di mana input pengguna diproses melalui komponen formulir dan divalidasi menggunakan skema validasi untuk memastikan kesesuaian data sebelum dikirimkan ke lapisan pengelolaan data. Pendekatan ini bertujuan untuk meminimalkan kesalahan data sejak tahap awal interaksi pengguna.

Setelah proses validasi, data diteruskan ke lapisan hooks yang mengimplementasikan TanStack Query sebagai pengelola utama server state. Pada tahap ini, TanStack Query berperan dalam mengoordinasikan pengiriman data ke backend melalui repository layer serta mengelola status eksekusi proses \textit{mutation}. Interaksi dengan query client memungkinkan TanStack Query menerapkan konfigurasi global yang konsisten terhadap perilaku \textit{mutation}, termasuk pengendalian pembaruan data setelah perubahan terjadi.

Respons dari backend yang diterima melalui repository layer kemudian diproses kembali pada lapisan \textit{Client Data Layer} dengan menerapkan tipe data melalui \textit{interface payload dan respons}. Tahapan ini memastikan bahwa data hasil \textit{mutation} memiliki struktur yang konsisten sebelum digunakan kembali oleh sistem \textit{frontend}. Selanjutnya, hasil pengelolaan \textit{mutation} dikembalikan ke lapisan antarmuka pengguna untuk memperbarui tampilan dashboard sesuai dengan kondisi data terbaru.

Dengan alur tersebut, mekanisme mutation tidak hanya berfungsi sebagai sarana pengiriman perubahan data ke backend, tetapi juga sebagai bagian dari pengendalian konsistensi data dan sinkronisasi antara \textit{frontend} dan backend. Implementasi ini memungkinkan antarmuka pengguna merespons setiap perubahan data secara terkontrol, sekaligus mendukung stabilitas dan kejelasan interaksi pada dashboard analitik.

Selain mekanisme pengelolaan data, TanStack Query juga menyediakan representasi state proses asinkron yang mencerminkan kondisi pemrosesan data, seperti keadaan pemuatan data (loading), keberhasilan proses (success), dan kegagalan (error). Representasi state ini dimanfaatkan untuk mengendalikan perilaku komponen antarmuka pengguna dalam merespons setiap kondisi tersebut. Dengan adanya informasi state yang terkelola secara terpusat, sistem \textit{frontend} mampu menampilkan indikator pemuatan data, pesan kesalahan, serta umpan balik keberhasilan secara konsisten, sehingga meningkatkan kejelasan interaksi dan pengalaman pengguna.

Implementasi paginasi diterapkan secara spesifik pada data komentar karena data tersebut bersifat volumetrik dan berpotensi tumbuh dalam jumlah besar, berbeda dengan data ringkasan sentimen dan tren yang bersifat agregat dan berukuran relatif kecil. Pada setiap permintaan data komentar, sistem hanya menampilkan sejumlah data terbatas, yaitu 10 komentar per halaman, sehingga jumlah data yang dikelola dan dirender oleh \textit{frontend} tetap terkendali.

Dengan pemisahan pengelolaan data tersebut, navigasi antar halaman komentar tidak memicu pemuatan ulang data ringkasan dan tren sentimen. TanStack Query memanfaatkan mekanisme \textit{query key} dan \textit{caching} untuk memastikan bahwa perubahan halaman hanya berdampak pada data komentar yang dipaginasi, sementara data agregat tetap diambil dari cache. Pendekatan ini memungkinkan dashboard tetap responsif meskipun jumlah total komentar yang dianalisis sangat besar, serta menunjukkan bahwa sistem memiliki batasan data yang jelas untuk menjaga performa aplikasi.
 
Secara keseluruhan, implementasi TanStack Query pada sistem yang dikembangkan menunjukkan peran yang signifikan dalam merealisasikan arsitektur \textit{Client Data Layer} secara operasional. Melalui pengelolaan mekanisme \textit{query} dan \textit{mutation}, TanStack Query memungkinkan pengambilan dan perubahan data dilakukan secara terpusat, konsisten, dan terkontrol. Hasil pengujian menunjukkan bahwa pendekatan ini mampu menjaga sinkronisasi data antara \textit{frontend} dan backend, mengcegah duplikasi request ke backend, serta memastikan konsistensi data sebelum dikirimkan ke lapisan presentasi atau UI. Dengan demikian, penerapan TanStack Query tidak hanya berfungsi sebagai solusi teknis pengelolaan data, tetapi juga berkontribusi terhadap keteraturan alur data.

\subsection{Implikasi Metode Fountain terhadap Iterasi Pengembangan Dashboard}

Implikasi penerapan metode Fountain juga tercermin dari dinamika iterasi yang terjadi selama proses pengembangan dashboard. Pada tahap implementasi, beberapa aktivitas pengembangan tidak selalu dilakukan secara berurutan, melainkan berlangsung secara tumpang tindih. Sebagai contoh, pengembangan fitur autentikasi berjalan paralel dengan perancangan fitur lain, sementara proses pengujian pada halaman data scraper dilakukan bersamaan dengan pengembangan tampilan dashboard. Pola ini menunjukkan bahwa tahapan analisis, perancangan, implementasi, dan pengujian tidak terisolasi secara kaku, melainkan saling memengaruhi sepanjang siklus pengembangan.

Selain itu, perubahan kebutuhan sistem yang muncul selama pengembangan turut memicu terjadinya iterasi balik ke tahap analisis. Penyesuaian pada tampilan dashboard mengharuskan evaluasi ulang terhadap komponen yang perlu disajikan, sehingga proses analisis dan perancangan dilakukan kembali meskipun implementasi beberapa fitur telah berjalan. Kondisi ini memperlihatkan bagaimana metode Fountain mendukung fleksibilitas dalam menghadapi perubahan kebutuhan tanpa harus mengulang proses pengembangan dari awal.

Pada tahap pengujian sistem secara keseluruhan, ditemukan adanya penambahan kebutuhan fungsional berupa integrasi fitur chatbot yang perlu diimplementasikan sebelum sistem dinyatakan siap digunakan. Penambahan fitur ini mendorong terjadinya iterasi lanjutan pada tahap perancangan dan implementasi, yang kemudian diikuti dengan proses pengujian ulang. Pola iterasi semacam ini menegaskan bahwa metode Fountain memungkinkan sistem berkembang secara adaptif terhadap kebutuhan baru yang muncul selama proses pengembangan berlangsung.

\subsection{Analisis Hasil dan Temuan Pengujian Sistem}

Berdasarkan hasil pengujian integrasi sistem, ditemukan temuan penting terkait perilaku sistem pada fase awal pemuatan dashboard setelah proses autentikasi pengguna. Pada kondisi tersebut, antarmuka pengguna menampilkan \textit{empty state} alih-alih \textit{loading state}, meskipun proses pengambilan data scraper dari backend masih berlangsung. Perilaku ini muncul secara konsisten ketika pengguna pertama kali diarahkan ke halaman dashboard setelah login.

Hasil analisis menunjukkan bahwa temuan tersebut disebabkan oleh urutan evaluasi state pada sisi \textit{frontend}, khususnya pada mekanisme sinkronisasi konteks dataset. Penentuan status dataset dilakukan berdasarkan kondisi data hasil pengambilan data scraper sebelum proses fetching selesai sepenuhnya. Akibatnya, kondisi data yang belum tersedia diinterpretasikan sebagai kondisi data kosong, sehingga sistem menetapkan status \textit{empty} meskipun data masih berada dalam fase pemuatan.

Temuan ini mengindikasikan adanya keterbatasan dalam pemisahan fase siklus hidup data (data \textit{lifecycle}) pada logika penentuan status sistem. Secara konseptual, kondisi \textit{loading} dan \textit{empty} merepresentasikan dua keadaan yang berbeda, namun dalam implementasi yang diuji, kedua kondisi tersebut belum dipisahkan secara eksplisit. Hal ini menyebabkan terjadinya ketidaksesuaian antara keadaan sistem yang sebenarnya dengan representasi antarmuka pengguna pada fase awal pemuatan.

Meskipun temuan tersebut tidak mengakibatkan kegagalan fungsional pada sistem, dampaknya terlihat pada pengalaman pengguna dan kejelasan interaksi awal dengan dashboard. Sistem tetap dapat menampilkan data dengan benar setelah proses pengambilan data selesai, namun representasi awal yang kurang akurat berpotensi menimbulkan kebingungan bagi pengguna. Temuan ini memberikan wawasan bahwa pengelolaan status sistem pada aplikasi dashboard yang bersifat data-driven perlu mempertimbangkan fase pemuatan data secara eksplisit agar kondisi antarmuka pengguna dapat mencerminkan keadaan sistem secara lebih tepat.

\subsection{Perbandingan dengan Penelitian Terdahulu dan Landasan Teori}

Penelitian ini tidak berfokus pada pengembangan atau evaluasi metode analisis sentimen, sebagaimana dilakukan pada penelitian \textit{Social Media Sentiment Analysis As a New Tool for Predicting Market Trends and Consumer Behaviour} oleh \citep{Fajarini2025}. Hasil penelitian ini menunjukkan bahwa tantangan utama pada pengembangan dashboard analitik justru terletak pada pengelolaan data hasil analisis di sisi \textit{frontend}, khususnya dalam menjaga konsistensi dan sinkronisasi data antar-komponen aplikasi.

Berbeda dengan penelitian \textit{React Query and Lazy Loading : Performance Optimization Best Practices} oleh \citep{Micheal2025}, hasil penelitian ini menegaskan peran TanStack Query sebagai bagian dari arsitektur Client Data Layer. Temuan pengujian menunjukkan bahwa penggunaan TanStack Query memengaruhi perilaku pengelolaan server state, terutama pada fase awal pemuatan data dan sinkronisasi data setelah perubahan terjadi.

Selain itu, pada penelitian \textit{Effective Data Visualization Techniques for Business Decision-Makers} oleh \citep{Rathore2025}, penelitian ini menitikberatkan pada aspek desain visual dan kejelasan penyajian informasi. Penelitian ini menunjukkan bahwa efektivitas visualisasi data pada dashboard analitik sangat bergantung pada alur pengelolaan data. Tanpa pengelolaan data yang terstruktur dan konsisten, kualitas visualisasi berpotensi menurun meskipun desain visual telah dirancang dengan baik.

Dengan demikian, penelitian ini melengkapi penelitian terdahulu dengan memberikan sudut pandang pada aspek arsitektur dan pengelolaan data \textit{frontend}. Kontribusi utama penelitian ini terletak pada analisis implikasi penerapan \textit{Client Data Layer} dan TanStack Query terhadap perilaku sistem \textit{frontend} dalam konteks dashboard analitik berbasis data sentimen, yang belum banyak dibahas pada penelitian sebelumnya.

\subsection{Dampak terhadap Skalabilitas dan Maintainability Sistem}

Penerapan arsitektur \textit{Client Data Layer} dan penggunaan TanStack Query memberikan implikasi terhadap potensi skalabilitas sistem \textit{frontend} yang dikembangkan. Dengan pengelolaan data yang terpusat pada lapisan tertentu, penambahan fitur baru yang bergantung pada data hasil analisis sentimen dapat dilakukan tanpa harus mengubah logika pengambilan data pada setiap komponen antarmuka. Pendekatan ini memungkinkan sistem \textit{frontend} berkembang secara modular, di mana penambahan atau perluasan fitur dapat dilakukan dengan dampak minimal mungkin terhadap fitur yang sudah ada.

Dari sisi skalabilitas pengelolaan data, mekanisme caching dan pembagian server state yang diterapkan melalui TanStack Query mendukung penggunaan data secara bersama oleh beberapa komponen dashboard. Hal ini mengurangi ketergantungan terhadap permintaan data berulang ke backend ketika jumlah komponen visualisasi atau kompleksitas dashboard meningkat. Dengan demikian, sistem memiliki karakteristik yang mendukung skalabilitas fungsional, khususnya pada aplikasi dashboard analitik yang menampilkan data di berbagai komponen.

Selain skalabilitas, penerapan arsitektur yang terstruktur juga berdampak terhadap maintainability sistem. Pemisahan tanggung jawab antara lapisan akses data, pengelolaan state, dan presentasi antarmuka memudahkan proses pemeliharaan dan penelusuran kesalahan. Perubahan pada struktur API atau logika pengelolaan data dapat dilakukan pada lapisan tertentu tanpa harus memodifikasi keseluruhan komponen antarmuka pengguna. Pendekatan ini membantu membatasi dampak perubahan dan mengurangi risiko terjadinya kesalahan yang menyebar ke berbagai bagian sistem.

Secara keseluruhan, hasil penelitian menunjukkan bahwa penerapan \textit{Client Data Layer} dan TanStack Query memberikan kontribusi positif terhadap potensi skalabilitas dan maintainability sistem \textit{frontend}. Meskipun penelitian ini tidak melakukan pengukuran kuantitatif terhadap performa atau beban sistem, karakteristik arsitektural yang diterapkan mendukung pengembangan sistem yang lebih terstruktur, adaptif terhadap perubahan, dan lebih mudah dipelihara dalam jangka panjang.

\subsection{Keterbatasan Penerapan TanStack Query dalam Penelitian}

TanStack Query dirancang secara khusus untuk mengelola data yang bersumber dari server, seperti proses pengambilan data, mekanisme caching, serta sinkronisasi data antara \textit{frontend} dan backend. Pendekatan ini berfokus pada pengelolaan \textit{server state}, yaitu data yang bersifat asinkron dan berasal dari sistem eksternal, sehingga tidak secara langsung mencakup pengelolaan \textit{client state} yang bersifat lokal dan tidak bergantung pada data server.

Dalam implementasi sistem yang dikembangkan, terdapat kebutuhan pengelolaan \textit{client state} yang berkaitan dengan konteks aplikasi, seperti pemilihan dataset aktif, pengaturan tampilan tertentu, serta pengendalian interaksi pengguna antar-halaman. Kebutuhan tersebut berada di luar ruang lingkup utama TanStack Query karena tidak melibatkan proses pengambilan atau sinkronisasi data dari server. Oleh karena itu, pengelolaan \textit{client state} dilakukan secara terpisah dari mekanisme pengelolaan data server.

Dengan pemisahan peran tersebut, TanStack Query tetap difungsikan secara spesifik sebagai lapisan \textit{Client Data Layer} yang bertanggung jawab atas pengelolaan data server, sementara \textit{client state} dikelola menggunakan mekanisme internal aplikasi sesuai kebutuhan. Pendekatan ini bertujuan menjaga fokus TanStack Query pada pengelolaan data asinkron, sekaligus mencegah kompleksitas arsitektur \textit{frontend} yang tidak diperlukan.

Temuan ini menunjukkan bahwa penerapan TanStack Query efektif untuk pengelolaan \textit{server state} pada aplikasi dashboard analitik, namun tidak dimaksudkan untuk menggantikan seluruh kebutuhan pengelolaan state di sisi klien. Oleh karena itu, evaluasi dalam penelitian ini difokuskan pada dampak penggunaan TanStack Query terhadap konsistensi data, mekanisme caching, dan pengendalian permintaan API, tanpa melibatkan perbandingan dengan pustaka \textit{state management} lainnya.
